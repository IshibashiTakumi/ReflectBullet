#pragma once

//=============================================================================
// タイトル	便利関数
// ファイル: utility.h
// 作成者:   石橋拓巳
// 作成日:   2016/11/22
//=============================================================================

//=============================================================================
//	インクルードファイル
//=============================================================================
#include "d3dx9.h"
#include <algorithm>
#include "fpsManager.h"

using namespace std;         //  名前空間指定

//=============================================================================
//
//	D3DXVECTOR2
//
//=============================================================================

//=============================================================================
//	D3DXVECTOR2の初期化
//=============================================================================
static inline D3DXVECTOR2 Vec2Init(void) { return D3DXVECTOR2(0.0f, 0.0f); }
//=============================================================================
//	aの長さの二乗
//=============================================================================
static inline float Vec2Length(const D3DXVECTOR2 &a) { return a.x * a.x + a.y * a.y; }
//=============================================================================
//	aの長さの平方根
//=============================================================================
static inline float Vec2LengthSq(const D3DXVECTOR2 &a) { return sqrtf(a.x * a.x + a.y * a.y); }
//=============================================================================
//	内積
//=============================================================================
static inline float Vec2Dot(const D3DXVECTOR2 &a, const D3DXVECTOR2 &b) { return (a.x * b.x) + (a.y * b.y); }
//=============================================================================
//	加算
//=============================================================================
static inline D3DXVECTOR2 Vec2Add(const D3DXVECTOR2 &a, const D3DXVECTOR2 &b) { return D3DXVECTOR2((a.x + b.x), (a.y + b.y)); }
//=============================================================================
//	減算
//=============================================================================
static inline D3DXVECTOR2 Vec2Sub(const D3DXVECTOR2 &a, const D3DXVECTOR2 &b) { return D3DXVECTOR2((a.x - b.x), (a.y - b.y)); }
//=============================================================================
//	正規化
//=============================================================================
static inline D3DXVECTOR2 Vec2Nor(const D3DXVECTOR2 &a) { float Lenght = Vec2LengthSq(a); return (Lenght == 0.0f) ? D3DXVECTOR2(0.0f, 0.0f) : D3DXVECTOR2((a.x / Lenght), (a.y / Lenght)); }

//=============================================================================
//
//	D3DXVECTOR3
//
//=============================================================================

//=============================================================================
//	D3DXVECTOR3の初期化
//=============================================================================
static inline D3DXVECTOR3 Vec3Init(void) { return D3DXVECTOR3(0.0f, 0.0f, 0.0); }
//=============================================================================
//	aの長さの二乗
//=============================================================================
static inline float Vec3Length(const D3DXVECTOR3 &a) { return a.x * a.x + a.y * a.y + a.z * a.z; }
//=============================================================================
//	aの長さの平方根
//=============================================================================
static inline float Vec3LengthSq(const D3DXVECTOR3 &a) { return sqrtf(a.x * a.x + a.y * a.y + a.z * a.z); }
//=============================================================================
//	内積
//=============================================================================
static inline float Vec3Dot(const D3DXVECTOR3 &a, const D3DXVECTOR3 &b) { return (a.x * b.x) + (a.y * b.y) + (a.z * b.z); }
//=============================================================================
//	外積
//=============================================================================
static inline D3DXVECTOR3 Vec3Cross(const D3DXVECTOR3 &a, const D3DXVECTOR3 &b) { return D3DXVECTOR3((a.y * b.z - a.z * b.y), (a.z * b.x - a.x * b.z), (a.x * b.y - a.y * b.x)); }
//=============================================================================
//	加算
//=============================================================================
static inline D3DXVECTOR3 Vec3Add(const D3DXVECTOR3 &a, const D3DXVECTOR3 &b) { return D3DXVECTOR3((a.x + b.x), (a.y + b.y), (a.z + b.z)); }
//=============================================================================
//	減算
//=============================================================================
static inline D3DXVECTOR3 Vec3Sub(const D3DXVECTOR3 &a, const D3DXVECTOR3 &b) { return D3DXVECTOR3((a.x - b.x), (a.y - b.y), (a.z - b.z)); }

//=============================================================================
//	絶対値の算出
//=============================================================================
static inline D3DXVECTOR3 Vec3Abs(const D3DXVECTOR3 &a) { return D3DXVECTOR3(fabs(a.x), fabs(a.y), fabs(a.z)); }

//=============================================================================
//	正規化
//=============================================================================
static inline D3DXVECTOR3 Vec3Nor(const D3DXVECTOR3 &a) { float Lenght = Vec3LengthSq(a); return (Lenght == 0.0f) ? D3DXVECTOR3(0.0f, 0.0f, 0.0f) : D3DXVECTOR3((a.x / Lenght), (a.y / Lenght), (a.z / Lenght)); }

//=============================================================================
//	回転の修正
//=============================================================================
static inline float RotCorrection(float Rot)
{
	if (Rot > D3DX_PI)
	{
		Rot -= D3DX_PI * 2;
	}
	else if (Rot < -D3DX_PI)
	{
		Rot += D3DX_PI * 2;
	}

	return Rot;
}

//=============================================================================
//
//	Convenient
//
//=============================================================================

//=============================================================================
//	最小値と最大値の間にクランプする
//=============================================================================
static inline float Clamp(float clamp, float _min, float _max) { return min(max(clamp, _min), _max); }

//=============================================================================
//
//	Template
//
//=============================================================================
// リソースの解放関数
template <class Resource>
void ResourceRelease(Resource& resource)
{
	if (resource != NULL)
	{
		resource->Release();
		resource = NULL;
	}
}

// リソースの削除関数
template <class Resource>
void ResourceUninit(Resource& resource)
{
	if (resource != NULL)
	{
		resource->Uninit();
		delete resource;
		resource = NULL;
	}
}

// リソースの削除関数
template <class Resource>
void ResourceDelete(Resource& resource)
{
	if (resource != NULL)
	{
		delete resource;
		resource = NULL;
	}
}

//=============================================================================
//
//	FrameTime
//
//=============================================================================

//=============================================================================
//	フレーム間の時間取得
//=============================================================================
static double FrameTime(void) { return CFpsManager::GetInstance()->GetFrameTime(); }